% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/differential_splicing.R
\name{differential_splicing}
\alias{differential_splicing}
\title{Perform pairwise differential splicing analysis.}
\usage{
differential_splicing(
  counts,
  x,
  confounders = NULL,
  max_cluster_size = 10,
  min_samples_per_intron = 5,
  min_samples_per_group = 4,
  min_coverage = 20,
  timeout = 10,
  robust = F,
  debug = F,
  init = "smart",
  ...
)
}
\arguments{
\item{counts}{An [introns] x [samples] matrix of counts. The rownames must be of the form chr:start:end:cluid. If the counts file comes from the leafcutter clustering code this should be the case already.}

\item{x}{A [samples] numeric vector, should typically be 0s and 1s, although in principle scaling shouldn't matter.}

\item{confounders}{A [samples] x [confounders] numeric matrix to be controlled for in the GLM. Factors should already have been converted to a 1-of-(K-1) encoding, e.g. using model.matrix (see scripts/leafcutter_ds.R for how to do this). Can be NULL, implying no covariates are controlled for.}

\item{max_cluster_size}{Don't test clusters with more introns than this}

\item{min_samples_per_intron}{Ignore introns used (i.e. at least one supporting read) in fewer than n samples}

\item{min_samples_per_group}{Require this many samples in each group to have at least min_coverage reads}

\item{min_coverage}{Require min_samples_per_group samples in each group to have at least this many reads}

\item{timeout}{Maximum time (in seconds) allowed for a single optimization run}

\item{robust}{Whether to use the robust model (explicitly models outliers). Generally not required/recommended for differential splicing.}

\item{debug}{If true writes more output}

\item{init}{One of 'smart' (default) or 'random'. If 'random' you can pass an additional arg "seed" for reproducibility.}
}
\value{
A per cluster list of results. Clusters that were not tested will be represented by a string saying why.
}
\description{
Parallelization across tested clusters is achieved using foreach/doMC, so the number of threads that will be used is determined by the cores argument passed to registerDoMC.
}
